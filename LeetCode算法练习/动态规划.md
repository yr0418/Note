### 1. 翻转数位

给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。

1. 示例 1

   输入: num = 1775 (11011101111)

   输出: 8

2. 示例 2

   输入: num = 7(0111)

   输出: 4



#### 解法：动态规划，逐位遍历

本题使用动态规划解决比较容易：使用用两个动态规划数组 current[]，reverse[]

- **current[i]** 表示包含第 $i$ 位的从num二进制低位至第 $i$ 位 连续1的最长长度。
- **reverse[i]** 表示包含第 $i$ 位的从低位到第 $i$ 位最多翻转1个0->1 的连续1的最长长度。
- 用 **num[i]** 表示整数 num 第 $i$ 位的值

当 **num[i]=1** 时，**current[i] = current[i-1]+1**，因为 **current[i-1]** 一定包含 **i-1** 位，也就是和第 $i$ 位连续，所以前 $i-1$ 的最大长度连上第 $i$ 位的长度就等于 **current[i]**，同理 **reverse[i] = reverse[i-1]+1**;

当 **num[i]=0** 时，连续中断，**current[i]=0**，而 **reverse[i]** 允许翻转1次，但是**reverse[i]** 又必须包含第 $i$ 位，也就是说只能翻转第 $i$ 位，所以前面不能出现翻转，必须全是1，这个长度恰好就是 **current[i-1]**，所以 **reverse[i] = current[i-1]+1**。

遍历 num 所有位数，也就是32位后，reverse 数组中的最大值就是答案。

状态方程：

1. **current[i] = num[i] == 1? current[i-1]+1: 0**
2. **reverse[i] = num[i] == 1? reverse[i-1]+1: current[i-1]+1**

观察状态方程，我们发现 current 和 reverse 第 $i$ 位只和第 $i-1$ 位有关，所以可以把动态数组优化成两个变量 current 和 reverse，同时更新最大值 max 并作为结果返回。

```java
public int reverseBits(int num) {
    int current = 0;
    int reverse = 0;
    int max = 0;
    for (int i = 0; i < 32; i++) {
        if ((num & 1) == 1) {
            current++;
            reverse++;
        } else {
            reverse = current+1;
            current = 0;
        }
        if (reverse > max) {
            max = reverse;
        }
        num >>= 1;
    }
    return max;
}

```

---



### 2. 三步问题

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

1. 示例1

   输入：n = 3 

   输出：4

   说明: 有四种走法

2. 示例2

   输入：n = 5

   输出：13

提示：n 范围在 [1, 1000000] 之间。



#### 解法：动态规划

**动态规划思想是希望连续的，也就是说上一个状态和下一个状态(自变量)之间有关系而且连续**。

$dp[i]$：表示爬到第 $i$ 阶楼梯所有的上楼的方式。

当爬第 $i$ 个阶梯时，有三种可能：

1. 从第 $i−1$ 个阶梯爬上来的（选择只爬一层）；
2. 从第 $i−2$ 个阶梯爬上来的（选择爬两层）；
3. 从第 $i−3$ 个阶梯爬上来的（选择爬三层）。

所以，爬到第 $i$ 个阶梯与 $dp[i - 1]、dp[i - 2]、dp[i - 3]$ 都有关系，则状态转移方程：
$$
dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
$$
初始化：由于直接操作了 $dp[i−1]、dp[i−2]、dp[i−3]$，所以 dp[1] = 1，dp[2] = 2，dp[3] = 4（即爬上第 3 层台阶有 4 中方法：[1, 1, 1]，[1, 2]，[2, 1]，[3]）。

注意：$dp[i - 1] + dp[i - 2]$ 在相加时会出现溢出的情况，所以要进行取模操作，并且每次得到一个 $dp[i]$ 后都要对它进行取模操作。

```java
public int waysToStep(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    if (n == 3) {
        return 4;
    }
    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    for (int i = 4; i < n+1; i++) {
        dp[i] = (dp[i-1] + dp[i-2])%1000000007 + dp[i-3];
        dp[i] %= 1000000007;
    }
    return dp[n];
}

```

---



### 3. 按摩师问题

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

1. 示例 1

   输入： [1,2,3,1]

   输出： 4

   解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

2. 示例 2

   输入： [2,7,9,3,1]

   输出： 12

   解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

3. 示例 3

   输入： [2,1,4,5,3,1,1,3]

   输出： 12

   解释： 选择 1、3、5、8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。



#### 解法

定义 $dp[i][0]$ 表示考虑前 $i$ 个预约，第 $i$ 个预约不接的最长预约时间，$dp[i][1]$ 表示考虑前 $i$ 个预约，第 $i$ 个预约接的最长预约时间。

从前往后计算 $dp$ 值，假设我们已经计算出前 $i−1$ 个 $dp$ 值，考虑计算 $dp[i][0/1]$ 的答案。

1. 首先考虑 $dp[i][0]$ 的转移方程，由于这个状态下第 $i$ 个预约是不接的，所以第 $i−1$ 个预约接或不接都可以，故可以从 $dp[i−1][0]$ 和 $dp[i−1][1]$ 两个状态转移过来，转移方程即为：$dp[i][0]=max(dp[i−1][0],dp[i−1][1])$
2. 对于 $dp[i][1]$ ，由于这个状态下第 $i$ 个预约要接，根据题目要求按摩师不能接受相邻的预约，所以第 $i−1$ 个预约不能接受，故我们只能从 $dp[i−1][0]$ 这个状态转移过来，转移方程即为：$dp[i][1]=dp[i−1][0]+nums_i$。其中 $nums_i$ 表示第 $i$ 个预约的时长。
3. 最后答案即为 $max(dp[n][0],dp[n][1])$ ，其中 n 表示预约的个数。

再回来看转移方程，我们发现计算 $dp[i][0/1]$ 时，只与前一个状态 $dp[i−1][0/1]$ 有关，所以我们可以不用开数组，只用两个变量 $dp_0$，$dp_1$ 分别存储 $dp[i−1][0]$ 和 $dp[i−1][1]$ 的答案，然后去转移更新答案即可。

```java
public int massage(int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    int dp0 = 0, dp1 = nums[0];
    int tdp0 = 0, tdp1 = 0;
    for (int i = 1; i < n; i++) {
        tdp0 = Math.max(dp0, dp1);
        tdp1 = dp0 + nums[i];
        dp0 = tdp0;
        dp1 = tdp1;
    }
    return Math.max(dp0, dp1);
}

```

---



### 4. 连续数列

给定一个整数数组，找出总和最大的连续数列，并返回总和。

1. 示例

   输入： [-2,1,-3,4,-1,2,1,-5,4]

   输出： 6

   解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。



#### 解法：动态规划

设置两个变量：cur 和 max，

- cur：记录当前连续子序列的总和，在总和小于等于 0 的情况下，应重置为 0；
- max：记录当前连续子序列的最大值，每次与 cur 比较，不断更新 max 的值。

最后返回 max 的值。

注意：要考虑数组全为负数的情况，为此，max 的初值应该设置为 nums[0]，同时，每次更新 cur 的值后，应该立刻与 max 进行比较，更新 max 的值，再在需要的情况下，重置 cur 的值。

```java
public int maxSubArray(int[] nums) {
    int max = nums[0], cur = 0;
    for (int i = 0; i < nums.length; i++) {
        cur += nums[i];
        max = Math.max(max, cur);
        if (cur <= 0) {
            cur = 0;
        }
    }
    return max;
}

```

---



### 5. 买卖股票的时机

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

1. 示例 1

   输入: [7,1,5,3,6,4]

   输出: 5

   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

2. 示例 2

   输入: [7,6,4,3,1]

   输出: 0

   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。



#### 解法：动态规划

假设给定的数组为：[7, 1, 5, 3, 6, 4]

如果我们在图表上绘制给定数组中的数字，我们将会得到：

![Profit Graph](https://pic.leetcode-cn.com/cc4ef55d97cfef6f9215285c7573027c4b265c31101dd54e8555a7021c95c927-file_1555699418271)

我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？

显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

```java
public int maxProfit(int prices[]) {
    int minprice = Integer.MAX_VALUE;
    int maxprofit = 0;
    for (int i = 0; i < prices.length; i++) {
        if (prices[i] < minprice) {
            minprice = prices[i];
        } else if (prices[i] - minprice > maxprofit) {
            maxprofit = prices[i] - minprice;
        }
    }
    return maxprofit;
}

```

---



### 6. 礼物的最大价值

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

1. 示例 1

```
输入:                     输出: 12
[                        解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
  [1,3,1],
  [1,5,1],
  [4,2,1]
]

```



#### 解法

题目说明：从棋盘的左上角开始拿格子里的礼物，并每次 向右 或者 向下 移动一格、直到到达棋盘的右下角。

根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。

设 $f(i, j)$ 为从棋盘左上角走至单元格 $(i ,j)$ 的礼物最大累计价值，易得到以下递推关系：
$$
f(i,j) = \max[f(i,j-1), f(i-1,j)] + grid(i,j)
$$
因此，可用动态规划解决此问题，以上公式便为转移方程。

![Picture1.png](https://pic.leetcode-cn.com/73153e75d74b1f48ac47244681caacc8ad20ca2ffd2dee2f70a2768dee09d073-Picture1.png)

**动态规划解析：**

状态定义： 设动态规划矩阵 $dp$ ，$dp(i,j)$ 代表从棋盘的左上角开始，到达单元格 $(i,j)$ 时能拿到礼物的最大累计价值。

**转移方程：**

1. 当 $i = 0$ 且 $j = 0$ 时，为起始元素；
2. 当 $i = 0$ 且 $j \ne 0$ 时，为矩阵第一行元素，只可从左边到达；
3. 当 $i \ne 0$ 且 $j = 0$ 时，为矩阵第一列元素，只可从上边到达；
4. 当 $i \ne 0$ 且 $j \ne 0$ 时，可从左边或上边到达；

$$
dp(i,j)= \begin{cases} grid(i,j) & {,i=0, j=0}\\ grid(i,j) + dp(i,j-1) & {,i=0, j \ne 0}\\ grid(i,j) + dp(i-1,j) & {,i \ne 0, j=0}\\ grid(i,j) + \max[dp(i-1,j),dp(i,j-1)]& ,{i \ne 0, j \ne 0} \end{cases}
$$

**初始状态：**$dp[0][0] = grid[0][0]$，即到达单元格 $(0,0)$ 时能拿到礼物的最大累计价值为 $grid[0][0]$；

**返回值：**$dp[m-1][n-1]$，m、n分别为矩阵的行高和列宽，即返回 dp 矩阵右下角元素。

**空间复杂度优化：**由于 $dp[i][j]$ 只与 $dp[i-1][j]$、$dp[i][j-1]$、$grid[i][j]$ 有关系，因此可以将原矩阵 grid 用作 dp 矩阵，即直接在 grid 上修改即可。应用此方法可省去 dp 矩阵使用的额外空间，因此空间复杂度从 $O(MN)$ 降至 $O(1)$。

```java
public int maxValue(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    for(int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            if(i == 0 && j == 0) {
                continue;
            }
            if(i == 0) {
                grid[i][j] += grid[i][j - 1] ;
            } else if(j == 0) {
                grid[i][j] += grid[i - 1][j];
            } else {
                grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]);
            }
        }
    }
    return grid[m - 1][n - 1];
}

```

---



