### 1. 判断字符是否唯一

实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

1. 示例 1

   输入: s = "leetcode"

   输出: false 

   

2. 示例 2

   输入: s = "abc"

   输出: true

限制：

- $0 <= len(s) <= 100$
- 如果你不使用额外的数据结构，会很加分。



#### 解法

我们可以使用一个 int 类型的变量（下文用 **mark** 表示）来代替长度为 $26$ 的 bool数组。假设这个变量占 26 个 bit（在多数语言中，这个值一般不止26，但是，我们只需要后26位即可）。

把它看成 **000...00**(26个0)，这 26 个bit对应着 26 个字符，对于一个字符 $c$，检查对应下标的 bit 值即可判断是否重复。那么难点在于如何检查。这里我们可以通过位运算来完成。

首先计算出字符 char 离 'a' 这个字符的距离，即我们要位移的距离，用 **move\_bit** 表示，那么使用左移运算符 **1 << move\_bit** 则可以得到对应下标为 1，其余下标为 0 的数，如字符 char = 'c'，则得到的数为 **000...00100**，将这个数跟 **mark** 做 **与运算**，由于这个数只有一个位为 1，其他位为 0，那么与运算的结果中，其他位肯定是0，而对应的下标位是否为 0 则取决于之前这个字符有没有出现过，若出现过则被标记为 1，那么与运算的结果就不为 0；若之前没有出现过，则对应位的与运算的结果也是 0，那么整个结果也为 0。

最后，对于没有出现过的字符形成的数字，我们将其跟 **mark** 做 **或运算**，将对应下标位的值置为1。

```java
public static boolean isUnique(String astr) {
    int aa = 0;
    int cc = 1;
    for (int i = 0; i < astr.length(); i++) {
      char t = astr.charAt(i);
      int offset = t - 'a';

      int bb = cc << offset;
      
      // 判断该字符是否已经出现
      if ((aa & bb) != 0) {
        return false;
      }
      
      // 该字符之前未出现，标记该字符
      aa |= bb;
    }

    return true;
  }

```

---



### 2. 回文排列

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。

1. 示例1

   输入："tactcoa"

   输出：true（排列有"tacocat"、"atcocta"，等等）



#### 解法

利用位运算中的 **异或** 运算。

对128位的 ASCII 码的字符，如果是用 int 类型，需要 4 位，但如果使用 long 类型，只需要两位就行了。一个记录 $0-63$，一个记录 $64-127$。每一位对应一个字符。同时对 Long 型的 **1L** 进行左移操作以标识字符串中各个字符。然后进行 **异或** 运算。这样，偶数个字符对应的标识位就会为 0，奇数个字符对应的标识位就会为 1。最后统计两个记录数中 1 的个数即可，若是回文排列，则 1 的个数只能是 0或1。

1. long 型数字，highBit 记录 64-127 位字符，lowBit 记录 0-63 位字符，初值均为 0
2. 遍历字符串，对其中的每一个字符，利用 ASCII 码进行计算确定，$0-63$ 位左移对应的位数，$64-127$ 位减去 64 后左移对应的位数，然后对长整型的 **1L** 进行移位；
3. 将移位后的数组与 highBit 或 lowBit 进行 **异或** 计算；
4. 统计两个记录数中的 1 的个数。

```java
public boolean canPermutePalindrome(String s) {
    long highBit = 0, lowBit = 0;
    for(char ch: s.toCharArray()) {
        if(ch > 63) {
            highBit ^= (1L << (ch-64));
        } else {
            lowBit ^= (1L << ch);
        }
    }
    return Long.bitCount(highBit) + Long.bitCount(lowBit) <= 1;
}

```

---



### 3. 整数转换

整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

1. 示例1

   输入：A = 29（11101），B = 15（01111）

   输出：2

2. 示例2

   输入：A = 1，B = 2

   输出：2

注意：A，B范围在[-2147483648, 2147483647]之间



#### 解法一：逐位遍历

由于 A，B 均不超过 32 位，因此采用逐位遍历的方式，从低位开始遍历 A 与 B，采用 **&1** 计算比较遍历到的位是否一致，采用 **count** 计数，最后返回 count 即可。

```java
public int convertInteger(int A, int B) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        if ((A&1) != (B&1)) {
            count++;
        }
        A >>= 1;
        B >>= 1;
    }
    return count;
}

```



#### 解法二：异或运算

**异或运算** 能找出 A、B 中的不同位。因此首先对 A、B 进行异或运算，在统计异或结果中 **1** 的个数即可。

把 C 中的 1 都变为0，需要几次，即为C中1的个数。**C & (C-1)** 会把 C 的最右边的 1 变为0，其余不变。

```java
public int convertInteger(int A, int B) {
    int count = 0;
    int C = A^B;
    while(C != 0) {
        C = C & (C-1);
        count++;
    }
    return count;
}

```

---



### 4. 配对交换

配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

1. 示例1

   输入：num = 2（0b10）

   输出：1(0b01)

2. 示例2

   输入：num = 3

   输出：3

提示：num的范围在 [0, 2^30 - 1] 之间，不会发生整数溢出。



#### 解法

**分别取出奇数位和偶数位，移位后做 或运算。**

题目规定 num 是 int 范围的数，则

- 0x55555555 = 0b0101_0101_0101_0101_0101_0101_0101_0101
- 0xaaaaaaaa = 0b1010_1010_1010_1010_1010_1010_1010_1010

用 num 分别与这两个数做 与运算，就可以把奇数位和偶数位取出来，然后：

1. 左移奇数位，右移偶数位；
2. 奇数位和偶数位做或运算并返回。

```java
public int exchangeBits(int num) {
    // 奇数位
    int odd = num & 0x55555555;
    // 偶数位
    int even = num & 0xaaaaaaaa;

    odd <<= 1;
    even >>= 1;
    
    return odd | even;
}

```

---



### 5. 最大值

编写一个方法，找出两个数字`a`和`b`中最大的那一个。不得使用 if-else 或其他比较运算符。

1. 示例

   输入： a = 1, b = 2

   输出： 2



#### 解法

1. 首先 a - b 得到差值x；
2. 由于是long型，右移63位得到符号位，注意负号不变，那么正数右移63位就是0，负数右移63位就是-1
3. 那么得出我们的计算公式 (1 + k) * a - b * k
   - 当 x >= 0 时，k = 0, 即 a > b；计算公式为 1 * a - b * 0 = a
   - 当 x < 0 时，k = -1, 即 b > a；计算公式为 0 * a - b * ( -1 ) = b

```java
public int maximum(int a, int b) {
    long x = (long)a - (long)b;
    int k = (int) (x >> 63);
    return (1+k)*a - b*k;
}

```

---



### 6. 只出现一次的数字

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现**两次**。找出那个只出现了一次的元素。

说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

1. 示例 1

   输入: [2,2,1]

   输出: 1



#### 解法：异或运算

异或运算有以下三个性质：

1. 任何数和 0 做异或运算，结果仍然是原来的数，即 $a \oplus 0=a$。
2. 任何数和其自身做异或运算，结果是 0，即 $a \oplus a=0$。
3. 异或运算满足交换律和结合律，即 $a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b$。

假设数组中有 2m+1 个数，其中有 m 个数各出现两次，一个数出现一次。令 $a_{1}、a_{2}、\ldots、a_{m}$ 为出现两次的 m 个数，$a_{m+1}$ 为出现一次的数。根据性质 3，数组中的全部元素的异或运算结果总是可以写成如下形式：
$$
(a_{1} \oplus a_{1}) \oplus (a_{2} \oplus a_{2}) \oplus \cdots \oplus (a_{m} \oplus a_{m}) \oplus a_{m+1}
$$
根据性质 2 和性质 1，上式可化简和计算得到如下结果：
$$
0 \oplus 0 \oplus \cdots \oplus 0 \oplus a_{m+1}=a_{m+1}
$$
因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。

```java
public int singleNumber(int[] nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        ans ^= nums[i];
    }
    return ans;
}

```

---



### 7. 颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

**提示：**请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

1. 示例 1

   输入：n = 00000010100101000001111010011100

   输出：964176192 (00111001011110000010100101000000)

   解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，因此返回 964176192，其二进制表示形式为00111001011110000010100101000000。



#### 解法：逐位颠倒

将 $n$ 视作一个长为 $32$ 的二进制串，从低位往高位枚举 $n$ 的每一位，将其倒序添加到翻转结果 $\textit{rev}$ 中。

代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。

需要注意的是，在某些语言（如 $\texttt{Java}$）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。

```java
public int reverseBits(int n) {
    int rev = 0;
    for (int i = 0; i < 32 && n != 0; ++i) {
        rev |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return rev;
}

```

---



### 8. 位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 **提示：**请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。

1. 示例 1

   输入：00000000000000000000000000001011

   输出：3

   解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。



#### 解法一：逐位检查

我们可以直接循环检查给定整数 n 的二进制位的每一位是否为 1。

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
       count += (n&1);
       // 由于 Java 中没有无符号整数类型，所以应使用逻辑右移
       n >>>= 1;
    }
    return count;
}

```





#### 解法二：位运算优化

观察这个运算：$n~\&~(n - 1)$，其运算结果恰为把 n 的二进制位中的最低位的 1 变为 0 之后的结果。如：$6~\&~(6-1) = 4、6 = (110)_2、4 = (100)_2$，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 n 与 n−1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的 1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
       n &= (n-1);
       count++;
    }
    return count;
}

```

---



### 9. 2的幂

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

1. 示例 1

   输入：n = 1

   输出：true

   解释：$2^0 = 1$

2. 示例 2

   输入：n = 16

   输出：true

   解释：$2^4 = 16$

3. 示例 3

   输入：n = 0

   输出：false



#### 解法：二进制位

**一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1。**

因此我们可以考虑使用位运算，将 n 的二进制表示中最低位的那个 1 提取出来，再判断剩余的数值是否为 0 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

**第一个技巧是：**$\texttt{n \& (n - 1)}$

$\texttt{\&}$ 表示按位与运算。该位运算技巧可以直接将 n 二进制表示的最低位 1 移除，它的原理如下：

> 假设 n 的二进制表示为 $(a 10\cdots 0)_2$，其中 a 表示若干个高位，1 表示最低位的那个 1，$0\cdots 0$ 表示后面的若干个 0，那么 n−1 的二进制表示为：$(a 01\cdots1)_2$，我们将 $(a 10\cdots 0)_2$ 与 $(a 01\cdots1)_2$ 进行按位与运算，高位 a 不变，在这之后的所有位都会变为 0，这样我们就将最低位的那个 1 移除了。

因此，如果 n 是正整数并且 $\texttt{n \& (n - 1) = 0}$，那么 n 就是 2 的幂。



**第二个技巧是：**$\texttt{n \& (-n)}$

−n 是 n 的相反数，是一个负数。该位运算技巧可以直接获取 n 二进制表示的最低位 1。

由于负数是按照补码规则在计算机中存储的，-n 的二进制表示为 n 的二进制表示的每一位取反再加上 1，因此它的原理如下：

> 假设 n 的二进制表示为 $(a 10\cdots 0)_2$，其中 a 表示若干个高位，1 表示最低位的那个 1，$0\cdots 0$ 表示后面的若干个 0，那么 −n 的二进制表示为：
>
> $(\bar{a} 01\cdots1)_2 + (1)_2 = (\bar{a} 10\cdots0)_2$ 
>
> 其中 $\bar{a}$ 表示将 a 每一位取反。我们将 $(a 10\cdots 0)_2$ 与 $(\bar{a} 10\cdots0)_2$ 进行按位与运算，高位全部变为 0，最低位的 1 以及之后的所有 0 不变，这样我们就获取了 n 二进制表示的最低位的 11。

因此，如果 n 是正整数并且 $\texttt{n \& (-n) = n}$，那么 n 就是 2 的幂。

```java
public boolean isPowerOfTwo (int n) {
    return n > 0 && (n & - n) == n;

}

```

---



### 10. 比特位计数

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

1. 示例 1

   输入：n = 2

   输出：[0,1,1]

   解释：$0 --> 0，1 --> 1，2 --> 10$

2. 示例 2

   输入：n = 5

   输出：[0,1,1,2,1,2]

   解释：$0 --> 0，1 --> 1，2 --> 10，3 --> 11，4 --> 100，5 --> 101$



#### 解法：动态规划+最高有效位

当计算 i 的「一比特数」时，如果存在 $0 \le j<i$，j 的「一比特数」已知，且 i 和 j 相比，i 的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。

令 $\textit{bits}[i]$ 表示 i 的「一比特数」，则上述关系可以表示成：$\textit{bits}[i]= \textit{bits}[j]+1$。

对于正整数 x，如果可以知道最大的正整数 y，使得 $y \le x$ 且 y 是 2 的整数次幂，则 y 的二进制表示中只有最高位是 1，其余都是 0，此时称 y 为 x 的「最高有效位」。令 $z=x-y$，显然 $0 \le z<x$，则 $\textit{bits}[x]=\textit{bits}[z]+1$。

显然，0 的「一比特数」为 0。使用 $\textit{highBit}$ 表示当前的最高有效位，遍历从 1 到 n 的每个正整数 i，进行如下操作。

1. 如果 $i~\&~(i-1)=0$，则令 $\textit{highBit}=i$，更新当前的最高有效位。
2. i 比 $i-\textit{highBit}$ 的「一比特数」多 1，由于是从小到大遍历每个整数，因此遍历到 i 时，$i-\textit{highBit}$ 的「一比特数」已知，令 $\textit{bits}[i]=\textit{bits}[i-\textit{highBit}]+1$。

最终得到的数组 $\textit{bits}$ 即为答案。

```java
public int[] countBits(int n) {
    int[] bits = new int[n+1];
    int highBit = 0;
    for (int i = 1; i <= n; i++) {
        if ((i & (i-1)) == 0) {
            highBit = i;
        }
        bits[i] = bits[i-highBit] + 1;
    }
    return bits;
}

```

---



### 11. 4的幂

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false。

1. 示例 1

   输入：n = 16

   输出：true



#### 解法

如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1，并且这个 1 出现在从低位开始的第偶数个二进制位上（这是因为这个 1 后面必须有偶数个 0）。这里我们规定最低位为第 0 位，例如 n=16 时，n 的二进制表示为 $(10000)_2$，唯一的 1 出现在第 4 个二进制位上，因此 n 是 4 的幂。

由于题目保证了 n 是一个 32 位的有符号整数，因此我们可以构造一个整数 $\textit{mask}$，它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。这样一来，我们将 n 和 $\textit{mask}$ 进行按位与运算，如果结果为 0，说明 n 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。

根据上面的思路，$\textit{mask}$ 的二进制表示为：$\textit{mask} = (10101010101010101010101010101010)_2$ 

我们也可以将其表示成 16 进制的形式，使其更加美观：$\textit{mask} = (\text{AAAAAAAA})_{16}$ 

```java
public boolean isPowerOfFour(int n) {
    return n > 0 && ((n & (n-1)) == 0) && (n & (0xaaaaaaaa)) == 0;
}

```

---



### 12. 数字转换为十六进制

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

**注意：**

- 十六进制中所有字母(a-f)都必须是小写。
- 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
- 给定的数确保在32位有符号整数范围内。
- 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。

1. 示例 1

   输入：26

   输出："1a"

2. 示例 2

   输入：-1

   输出："ffffffff"



#### 解法：位运算

题目要求将给定的整数 $\textit{num}$ 转换为十六进制数，负整数使用补码运算方法。

在补码运算中，最高位表示符号位，符号位是 0 表示正整数和零，符号位是 1 表示负整数。32 位有符号整数的二进制数有 32 位，由于一位十六进制数对应四位二进制数，因此 32 位有符号整数的十六进制数有 8 位。将 $\textit{num}$ 的二进制数按照四位一组分成 8 组，依次将每一组转换为对应的十六进制数，即可得到 $num$ 的十六进制数。

假设二进制数的 8 组从低位到高位依次是第 0 组到第 7 组，则对于第 $i$ 组，可以通过$(nums>>(4×i)) \& 0xf$ 得到该组的值，其取值范围是 0 到 15。将每一组的值转换为十六进制数的做法如下：

1. 对于 0 到 9，数字本身就是十六进制数；
2. 对于 10 到 15，将其转换为 $a$ 到 $f$ 中的对应字母。

对于负整数，由于最高位一定不是 0，因此不会出现前导零。对于零和正整数，可能出现前导零。避免前导零的做法如下：

1. 如果 $num=0$，则直接返回 0；

2. 如果 $num>0$，则在遍历每一组的值时，从第一个不是 0 的值开始拼接成十六进制数。

```java
public String toHex(int num) {
    if (num == 0) {
        return "0";
    }
    StringBuffer sb = new StringBuffer();
    for (int i = 7; i >= 0; i --) {
        int val = (num >> (4 * i)) & 0xf;
        if (sb.length() > 0 || val > 0) {
            char digit = val < 10 ? (char) ('0' + val) : (char) ('a' + val - 10);
            sb.append(digit);
        }
    }
    return sb.toString();
}

```

---



### 13 数字的补数

对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。

给你一个整数 num ，输出它的补数。

1. 示例 1

   输入：num = 5

   输出：2

   解释：5 的二进制表示为 101（没有前导零位），其补数为 010，输出 2。

2. 示例 2

   输入：num = 1

   输出：0

   解释：1 的二进制表示为 1（没有前导零位），其补数为 0，输出 0 。

**提示：**$1 \le num < 2^{31}$



#### 解法：位运算

根据题目的要求，我们需要将 $num$ 二进制表示的每一位取反。然而在计算机存储整数时，并不会仅仅存储有效的二进制位。例如当 $num=5$ 时，它的二进制表示为 $(101)$，而使用 $32$ 位整数存储时的结果为：$(0000~0000~0000~0000~0000~0000~0000~0101)_2$

因此我们需要首先找到 $num$ 二进制表示最高位的那个 1，再将这个 1 以及更低的位进行取反。

如果 $num$ 二进制表示最高位的 1 是第 $i$ $(0≤i≤30)$ 位，那么一定有：$2^i \leq \textit{num} < 2^{i+1}$ 因此我们可以使用一次遍历，在 $[0,30]$ 中找出 $i$ 的值。在这之后，我们就可以遍历 $num$ 的第 $0 \sim i$ 个二进制位，将它们依次进行取反。我们也可以用更高效的方式，构造掩码 $\textit{mask} = 2^{i+1} - 1$，它是一个 $i+1$ 位的二进制数，并且每一位都是 1。我们将 $\textit{num}$ 与 $\textit{mask}$ 进行异或运算，即可得到答案。

**细节：**当 $i=30$ 时，构造 $\textit{mask} = 2^{i+1} - 1$ 的过程中需要保证不会产生整数溢出。下面部分语言的代码中对该情况进行了特殊判断。

```java
public int findComplement(int num) {
    int highbit = 0;
    for (int i = 1; i <= 30; ++i) {
        if (num >= 1 << i) {
            highbit = i;
        } else {
            break;
        }
    }
    int mask = highbit == 30 ? 0x7fffffff : (1 << (highbit + 1)) - 1;
    return num ^ mask;
}

```

---



